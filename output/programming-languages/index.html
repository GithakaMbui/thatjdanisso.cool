<!DOCTYPE html>
<html lang="en">
  <head>
    <title>
      A Frontend Programmer&#39;s Guide to Languages | jordan scales
    </title>

    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/tomorrow.min.css" />
    <link rel="stylesheet" href="/css/demos/clicking.css" />
    <link rel="stylesheet" href="/css/demos/hover.css" />
    <link rel="stylesheet" href="/css/demos/shared.css" />
    <link rel="stylesheet" href="/css/katex.min.css" />

    <link
      href="https://fonts.googleapis.com/css?family=Inconsolata:400,700&font-display=swap"
      rel="stylesheet"
      type="text/css"
    />
    <meta charset="utf-8" />
    <meta name="viewport" content="width=480" />
    <link
      rel="Shortcut Icon"
      type="image/x-icon"
      href="https://s.gravatar.com/avatar/3517596df161030c3779c532f7844383?s=32.gif"
    />

    <meta
      property="og:title"
      content="A Frontend Programmer&#39;s Guide to Languages | jordan scales"
    />
    <meta
      name="Description"
      content="Today, we&#39;re going to make a programming language. No, it won&#39;t take a PhD, or years of your time (or even days for that matter). You and I, together, are going to learn what a programming language is and actually build one that can evaluate programs."
    />
    <meta
      property="og:description"
      content="Today, we&#39;re going to make a programming language. No, it won&#39;t take a PhD, or years of your time (or even days for that matter). You and I, together, are going to learn what a programming language is and actually build one that can evaluate programs."
    />
    <meta
      property="og:image"
      content="https://s.gravatar.com/avatar/3517596df161030c3779c532f7844383?s=32.gif"
    />
  </head>

  <body>
    <div class="main">
      <header>
        <span class="flash" aria-hidden="true">////////</span>
        <strong>jordan scales</strong>
        <span class="sep" aria-hidden="true">.</span>
        <a href="/">home</a>
        <span class="sep" aria-hidden="true">.</span>
        <a href="/projects">projects</a>
        <span class="sep" aria-hidden="true">.</span>
        <a href="https://twitter.com/jdan">twitter</a>
        <span class="sep" aria-hidden="true">.</span>
        <a href="https://github.com/jdan">github</a>
      </header>

      <article class="article">
        <header class="title">
          <div class="date">
            April 13, 2019
          </div>

          <h1>A Frontend Programmer&#39;s Guide to Languages</h1>
        </header>

        <section class="content">
          <p>Today, we&#39;re going to make a programming language.</p>
          <p>
            No, it won&#39;t take a PhD, or years of your time (or even days for
            that matter). You and I, together, are going to learn what a
            programming language <em>is</em> and actually build one that can
            evaluate programs.
          </p>
          <p>
            By the end of this post we&#39;ll have written a JavaScript
            function, <code>evaluate</code>, which interprets a small
            programming language with strings and variables. You won&#39;t be
            going off and rewriting your stack in it (though you&#39;re
            certainly welcome to try!), but I hope it&#39;s a fun exercise.
          </p>
          <p>
            I encourage you to copy the code examples in your editor of choice
            and actually run them. You should be able to make it through this
            post in a single listen of
            <a
              href="https://open.spotify.com/album/1u8OmwItT46Y1gD2xKAK9D?si=CcY4GgT4TGyOa7eNcnLqTA"
              >Lights - Little Machines</a
            >.
          </p>
          <h2 id="hello-world">Hello, world!</h2>
          <p>
            To kick things off, we&#39;ll write an interpreter for a new
            HelloWorld language, and use it write a
            <a href="https://en.wikipedia.org/wiki/%22Hello,_World!%22_program"
              >Hello, world! program</a
            >.
          </p>
          <p>Here&#39;s our goal:</p>
          <pre><code class="language-js"><span class="hljs-keyword">const</span> program = { <span class="hljs-attr">type</span>: <span class="hljs-string">"HelloWorld"</span> }
<span class="hljs-built_in">console</span>.log(evaluate(program))
<span class="hljs-comment">// =&gt; Hello, world!</span></code></pre>
          <p>
            I&#39;m sure you have questions. <em>Real quick</em>, let&#39;s
            introduce some terms that we&#39;ll more clearly define as we go.
          </p>
          <ul>
            <li>
              Our &quot;<strong>program</strong>&quot; is represented by the
              JavaScript object <code>{ type: &quot;HelloWorld&quot; }</code>.
              Throughout this post, we&#39;ll be adding more and more things to
              this object. For now, there&#39;s not much to it.
            </li>
            <li>
              Our &quot;<strong>evaluator</strong>&quot; (or
              &quot;interpreter&quot; - it&#39;s your call) is a single
              JavaScript function that accepts a
              &quot;<strong>program</strong>.&quot;
            </li>
            <li>
              We receive a &quot;<strong>value</strong>&quot; from our
              &quot;<strong>evaluator</strong>,&quot; which we send to the
              wonderful <code>console.log</code> function you&#39;re all
              familiar with.
            </li>
          </ul>
          <p>Now let&#39;s build our <strong>evaluator</strong>.</p>
          <pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">evaluate</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">switch</span> (node.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">"HelloWorld"</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello, world!"</span>
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">throw</span> <span class="hljs-string">`evaluate -- unknown node type <span class="hljs-subst">${node.type}</span>`</span>
  }
}</code></pre>
          <p>
            This function is not terribly interesting, but I&#39;d like to call
            out a few details.
          </p>
          <ul>
            <li>
              Our function accepts a parameter that we call <code>node</code> as
              in, a <strong>node</strong> of a tree. (<em
                >dramatic foreshadowing</em
              >)
            </li>
            <li>
              The crux of this function is a single
              <code>switch</code> statement that operates on the
              <code>type</code> field of our node. Our language is very simple,
              so we only have a single &quot;node type&quot; (namely,
              &quot;HelloWorld&quot;).
            </li>
            <li>
              For the &quot;HelloWorld&quot; <strong>expression</strong> - we
              return the string &quot;Hello, world!&quot;
            </li>
            <li>
              If we see something we don&#39;t recognize - we throw an error.
              The programmer messed up!
            </li>
          </ul>
          <p>
            At this point we have 8 lines of code that evaluate a simple
            HelloWorld language. I&#39;ll emphasize the <em>simple</em> here,
            there are no variables, no loops, no modules, not even numbers - but
            it&#39;s a language. Our language has a very small
            <strong>grammar</strong>, but it&#39;s a language.
          </p>
          <p>Let&#39;s make things more interesting.</p>
          <h2 id="strings">Strings</h2>
          <p>
            In this section we&#39;d like to make a new
            <code>HelloStrings</code> language (marketing wants us to be able to
            print more than just &quot;Hello, world!&quot;) that can produce
            strings and run two operations on them.
          </p>
          <p>Here&#39;s our goal for this section:</p>
          <pre><code class="language-js"><span class="hljs-built_in">console</span>.log(
  evaluate({
    <span class="hljs-attr">type</span>: <span class="hljs-string">"String"</span>,
    <span class="hljs-attr">content</span>: <span class="hljs-string">"Apple"</span>,
  })
)
<span class="hljs-comment">// =&gt; Apple</span>

<span class="hljs-built_in">console</span>.log(
  evaluate({
    <span class="hljs-attr">type</span>: <span class="hljs-string">"Excite"</span>,
    <span class="hljs-attr">expression</span>: {
      <span class="hljs-attr">type</span>: <span class="hljs-string">"String"</span>,
      <span class="hljs-attr">content</span>: <span class="hljs-string">"Banana"</span>,
    },
  })
)
<span class="hljs-comment">// =&gt; Banana!</span>

<span class="hljs-built_in">console</span>.log(
  evaluate({
    <span class="hljs-attr">type</span>: <span class="hljs-string">"Append"</span>,
    <span class="hljs-attr">first</span>: {
      <span class="hljs-attr">type</span>: <span class="hljs-string">"String"</span>,
      <span class="hljs-attr">content</span>: <span class="hljs-string">"Apple"</span>,
    },
    <span class="hljs-attr">second</span>: {
      <span class="hljs-attr">type</span>: <span class="hljs-string">"Excite"</span>,
      <span class="hljs-attr">expression</span>: {
        <span class="hljs-attr">type</span>: <span class="hljs-string">"String"</span>,
        <span class="hljs-attr">content</span>: <span class="hljs-string">"Banana"</span>,
      },
    },
  })
)
<span class="hljs-comment">// =&gt; AppleBanana!</span></code></pre>
          <p>Some initial observations:</p>
          <ul>
            <li>
              We ditch our &quot;HelloWorld&quot; <strong>expression</strong> in
              favor of &quot;String,&quot; which has a &quot;content&quot; field
              in addition to the &quot;type&quot; field we used in the previous
              section.
            </li>
            <li>
              We introduce &quot;Excite&quot; which adds exclamation points to
              expressions.
            </li>
            <li>
              We introduce &quot;Append,&quot; which also contains expressions
              in its definition - two of &#39;em in fact!
            </li>
          </ul>
          <p>
            Let&#39;s start off by creating an <strong>evaluator</strong> to
            operate on &quot;String&quot; expressions.
          </p>
          <pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">evaluate</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">switch</span> (node.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">"String"</span>:
      <span class="hljs-keyword">return</span> node.content
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">throw</span> <span class="hljs-string">`evaluate -- unknown node type <span class="hljs-subst">${node.type}</span>`</span>
  }
}</code></pre>
          <p>
            Great, so we replace &quot;HelloWorld&quot; with &quot;String&quot;
            as the node&#39;s type - and return its &quot;content&quot; value
            instead of the string &quot;Hello, world!&quot;
          </p>
          <p>
            <strong
              ><em
                >You just wrote a programming language with strings, let&#39;s
                celebrate!</em
              ></strong
            >
          </p>
          <p>
            But if we continue with our desired goal above, we see the
            following:
          </p>
          <pre><code>Apple
evaluate -- unknown node<span class="hljs-built_in"> type </span>Excite</code></pre>
          <p>
            We can evaluate
            <code
              >{ type: &quot;String&quot;, content: &quot;Apple&quot; }</code
            >
            no problem, but we don&#39;t know what to do with this
            &quot;Excite&quot; thing just yet.
          </p>
          <p>
            So how might we evaluate &quot;Excite&quot; expressions? Based on
            how it produces &quot;Banana!&quot; in our desired output, we may be
            inclined to say that &quot;Excite&quot;
            <em>takes a string and adds an exclamation point to it</em>. Simple
            enough, right? But let&#39;s take a closer look.
          </p>
          <pre><code class="language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">"Excite"</span>,
  <span class="hljs-attr">expression</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">"String"</span>,
    <span class="hljs-attr">content</span>: <span class="hljs-string">"Banana"</span>
  }
}</code></pre>
          <p>
            The &quot;expression&quot; field of our Excite expression node
            isn&#39;t a string per se, but an expression in the HelloStrings
            language!
            <strong>Our expression contains an expression inside of it!</strong>
            (Are you beginning to see why our evaluator accepts a
            <code>node</code> as in &quot;nodes of a tree&quot;?)
          </p>
          <p>
            To illustrate this further, allow me to propose the following,
            <em>valid</em> program for the HelloStrings language.
          </p>
          <pre><code class="language-js"><span class="hljs-built_in">console</span>.log(
  evaluate({
    <span class="hljs-attr">type</span>: <span class="hljs-string">"Excite"</span>,
    <span class="hljs-attr">expression</span>: {
      <span class="hljs-attr">type</span>: <span class="hljs-string">"Excite"</span>,
      <span class="hljs-attr">expression</span>: {
        <span class="hljs-attr">type</span>: <span class="hljs-string">"String"</span>,
        <span class="hljs-attr">content</span>: <span class="hljs-string">"Banana"</span>,
      },
    },
  })
)</code></pre>
          <p>
            In the above example, we&#39;ll evaluate the string
            &quot;Banana&quot; - excite it to get &quot;Banana!&quot; - than
            excite <em>that</em> to get &quot;Banana!!&quot; (how very
            exciting!)
          </p>
          <p>Let&#39;s begin adding Excite expressions to our language.</p>
          <pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">evaluate</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">switch</span> (node.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">"String"</span>:
      <span class="hljs-keyword">return</span> node.content;
    <span class="hljs-keyword">case</span> <span class="hljs-string">"Excite"</span>:
      <span class="hljs-comment">// We have this node.expression thing, but what do</span>
      <span class="hljs-comment">// we do with it?</span>
      ???
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">throw</span> <span class="hljs-string">`evaluate -- unknown node type <span class="hljs-subst">${node.type}</span>`</span>;
  }
}</code></pre>
          <p>
            Rather than just returning a &quot;value&quot; like we did for
            String expressions (<code>return node.content</code>), we&#39;ll
            need to use <code>node.expression</code> somehow. As the name
            suggests, <code>node.expression</code> is an expression, and what do
            we do with expressions?
          </p>
          <p>We evaluate them!</p>
          <pre><code class="language-js"><span class="hljs-keyword">case</span> <span class="hljs-string">"Excite"</span>:
  <span class="hljs-keyword">return</span> evaluate(node.expression) + <span class="hljs-string">"!"</span>;</code></pre>
          <p>
            <code>evaluate</code> is now a recursive function which operates on
            String and Excite expressions. Here&#39;s the function in all its
            glory and an invitation to implement <code>Append</code> yourself.
          </p>
          <pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">evaluate</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">switch</span> (node.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">"String"</span>:
      <span class="hljs-keyword">return</span> node.content
    <span class="hljs-keyword">case</span> <span class="hljs-string">"Excite"</span>:
      <span class="hljs-keyword">return</span> evaluate(node.expression) + <span class="hljs-string">"!"</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">"Append"</span>:
    <span class="hljs-comment">// Now it's your turn, how might we evaluate</span>
    <span class="hljs-comment">// Append expressions?</span>
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">throw</span> <span class="hljs-string">`evaluate -- unknown node type <span class="hljs-subst">${node.type}</span>`</span>
  }
}</code></pre>
          <h2 id="variables">Variables</h2>
          <p>
            At this point we have a small language which can produce strings
            with &quot;Excite&quot; and &quot;Append&quot; statements. Nice job
            if you&#39;ve made it this far!
          </p>
          <p>
            Let&#39;s use this momentum and expand our language to support a
            very popular language construct - <strong>variables</strong>.
          </p>
          <p>
            By the end of this section, we&#39;ll have a language which can
            declare and retrieve the value of variables in HelloStrings
            expressions.
          </p>
          <pre><code class="language-js"><span class="hljs-built_in">console</span>.log(
  evaluate(
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">"Let"</span>,
      <span class="hljs-attr">name</span>: <span class="hljs-string">"x"</span>,
      <span class="hljs-attr">value</span>: {
        <span class="hljs-attr">type</span>: <span class="hljs-string">"String"</span>,
        <span class="hljs-attr">content</span>: <span class="hljs-string">"Hello, world"</span>,
      },
      <span class="hljs-attr">expression</span>: {
        <span class="hljs-attr">type</span>: <span class="hljs-string">"Excite"</span>,
        <span class="hljs-attr">expression</span>: {
          <span class="hljs-attr">type</span>: <span class="hljs-string">"Variable"</span>,
          <span class="hljs-attr">name</span>: <span class="hljs-string">"x"</span>,
        },
      },
    },
    {}
  )
)
<span class="hljs-comment">// =&gt; Hello, world!</span></code></pre>
          <p>There&#39;s a lot there, so let&#39;s break it down.</p>
          <ul>
            <li>
              <code>evaluate</code> now takes a second argument (<em
                >dramatic foreshadowing</em
              >)
            </li>
            <li>
              We introduce a new &quot;Variable&quot; expression, which will
              <strong>lookup</strong> a variable by its name.
            </li>
            <li>
              We introduce a &quot;Let&quot; expression, which makes a new
              variable with a &quot;name&quot; and a &quot;value&quot; (the
              value being an expression in our language!), and uses that when
              evaluating an inner <strong>expression</strong>.
            </li>
          </ul>
          <p>
            In our case, we&#39;re setting &quot;x&quot; to the evaluation of a
            &quot;Hello, world&quot; String, then retrieving the value of
            &quot;x&quot; to Excite it.
          </p>
          <p>
            Let&#39;s start by adding &quot;Variable&quot; expressions to
            <code>evaluate</code>.
          </p>
          <pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">evaluate</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">switch</span> (node.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">"Variable"</span>:
      <span class="hljs-comment">// We have `node.name`, but what to do with it?</span>
    ...
  }
}</code></pre>
          <p>Consider the following code:</p>
          <pre><code class="language-js">evaluate({ <span class="hljs-attr">type</span>: <span class="hljs-string">"Variable"</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"x"</span> })</code></pre>
          <p>
            Here we want to evaluate the variable <code>x</code>, but there
            doesn&#39;t seem to be much to work with. In a typical programming
            language, what we might we do with a variable?
          </p>
          <p>We look it up!</p>
          <pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">evaluate</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">switch</span> (node.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">"Variable"</span>:
      <span class="hljs-keyword">return</span> lookup(node.name);
    ...
  }
}
</code></pre>
          <p>
            In order for <code>lookup</code> to do anything meaningful, we need
            to provide it with some sort of <strong>environment</strong> - a
            collection of variable names and values. We&#39;ll call this
            <code>env</code>.
          </p>
          <pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">evaluate</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">switch</span> (node.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">"Variable"</span>:
      <span class="hljs-keyword">return</span> lookup(env, node.name);
    ...
  }
}
</code></pre>
          <p>
            And where does <code>env</code> come from? Rather unfortunately we
            can&#39;t make it out of thin air (believe me, I tried for many
            hours), but we <em>can</em>
            <strong>pass it in to our evaluator.</strong>
          </p>
          <pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">evaluate</span>(<span class="hljs-params">node, env</span>) </span>{
  <span class="hljs-keyword">switch</span> (node.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">"Variable"</span>:
      <span class="hljs-keyword">return</span> lookup(env, node.name)
    <span class="hljs-keyword">case</span> <span class="hljs-string">"String"</span>:
      <span class="hljs-keyword">return</span> node.content
    <span class="hljs-keyword">case</span> <span class="hljs-string">"Excite"</span>:
      <span class="hljs-keyword">return</span> evaluate(node.expression, env) + <span class="hljs-string">"!"</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">"Append"</span>:
    <span class="hljs-comment">// Left as an exercise to the reader</span>
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">throw</span> <span class="hljs-string">`evaluate -- unknown node type <span class="hljs-subst">${node.type}</span>`</span>
  }
}</code></pre>
          <p>
            <em
              >Remember to add <code>env</code> to our recursive calls in Excite
              and Append (you did implement Append, right?)</em
            >
          </p>
          <p>
            Let&#39;s define <code>lookup</code>. For simplicity&#39;s sake,
            we&#39;ll say an environment is a JavaScript object with
            <code>name</code> keys and <code>value</code> values.
          </p>
          <pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lookup</span>(<span class="hljs-params">env, name</span>) </span>{
  <span class="hljs-keyword">return</span> env[name]
}</code></pre>
          <p>Simple, right?</p>
          <pre><code class="language-js"><span class="hljs-built_in">console</span>.log(evaluate({ <span class="hljs-attr">type</span>: <span class="hljs-string">"Variable"</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"x"</span> }, { <span class="hljs-attr">x</span>: <span class="hljs-string">"Hello, world!"</span> }))
<span class="hljs-comment">// =&gt; Hello, world!</span></code></pre>
          <p>
            <strong
              >Congratulations you just added variables to your
              language!</strong
            >
          </p>
          <p>
            Last but not least, we&#39;ll want an easy way to create new
            variables. Without this, we&#39;ll be evaluating Excite&#39;s and
            Append&#39;s with nothing more than a bunch of global variables -
            and the marketing department <em>definitely</em> doesn&#39;t want
            that.
          </p>
          <p>
            Let&#39;s start by listing what a &quot;Let&quot; expression
            actually contains:
          </p>
          <pre><code class="language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">"Let"</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">"x"</span>,
  <span class="hljs-attr">value</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">"String"</span>,
    <span class="hljs-attr">content</span>: <span class="hljs-string">"Hello, world"</span>
  },
  <span class="hljs-attr">expression</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">"Excite"</span>,
    <span class="hljs-attr">expression</span>: {
      <span class="hljs-attr">type</span>: <span class="hljs-string">"Variable"</span>,
      <span class="hljs-attr">name</span>: <span class="hljs-string">"x"</span>
    }
  }
}</code></pre>
          <ul>
            <li>A &quot;Let&quot; type</li>
            <li>A &quot;name&quot; field for naming our new variable</li>
            <li>
              A &quot;value&quot; field for giving our new variable a value
            </li>
            <li>An &quot;expression&quot; field to use our new variable in!</li>
          </ul>
          <p>Excellent, now let&#39;s get started on implementing the thing.</p>
          <pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">evaluate</span>(<span class="hljs-params">node, env</span>) </span>{
  <span class="hljs-keyword">switch</span> (node.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">"Variable"</span>:
      <span class="hljs-keyword">return</span> lookup(env, node.name);
    <span class="hljs-keyword">case</span> <span class="hljs-string">"Let"</span>:
      <span class="hljs-keyword">let</span> newEnv = ???
      <span class="hljs-keyword">return</span> evaluate(node.expression, newEnv);
    ...
  }
}</code></pre>
          <p>
            We&#39;ll be
            <strong>adding a new variable to our environment</strong>, and using
            that to evaluate our expression. For simplicity&#39;s sake,
            let&#39;s give ourselves an <code>extendEnv</code> function to do
            this.
          </p>
          <pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">evaluate</span>(<span class="hljs-params">node, env</span>) </span>{
  <span class="hljs-keyword">switch</span> (node.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">"Variable"</span>:
      <span class="hljs-keyword">return</span> lookup(env, node.name);
    <span class="hljs-keyword">case</span> <span class="hljs-string">"Let"</span>:
      <span class="hljs-keyword">let</span> name = ???
      <span class="hljs-keyword">let</span> value = ???
      <span class="hljs-keyword">let</span> newEnv = extendEnv(env, name, value)
      <span class="hljs-keyword">return</span> evaluate(node.expression, newEnv);
    ...
  }
}</code></pre>
          <p>
            <code>name</code> is simple, that&#39;s just <code>node.name</code>.
            For <code>value</code>, however, we&#39;ll be given a
            <em>HelloStrings expression</em> to evaluate.
          </p>
          <pre><code class="language-js">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">"Let"</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">"x"</span>,
  <span class="hljs-attr">value</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">"String"</span>,
    <span class="hljs-attr">content</span>: <span class="hljs-string">"Hello, world"</span>
  },
  ...
}</code></pre>
          <p>Still, it&#39;s not much code :)</p>
          <pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">evaluate</span>(<span class="hljs-params">node, env</span>) </span>{
  <span class="hljs-keyword">switch</span> (node.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">"Variable"</span>:
      <span class="hljs-keyword">return</span> lookup(env, node.name);
    <span class="hljs-keyword">case</span> <span class="hljs-string">"Let"</span>:
      <span class="hljs-keyword">let</span> name = node.name;
      <span class="hljs-keyword">let</span> value = evaluate(node.value, env);
      <span class="hljs-keyword">let</span> newEnv = extendEnv(env, name, value);
      <span class="hljs-keyword">return</span> evaluate(node.expression, newEnv);
    ...
  }
}</code></pre>
          <p>Finally, <code>extendEnv</code>.</p>
          <p>
            Our <code>env</code> is a simple JavaScript object that maps
            <code>names</code> to <code>values</code>. We&#39;ll need to extend
            an <code>env</code> with a <em>new</em> name and value pair. We can
            do so with <code>Object.assign</code>:
          </p>
          <pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extendEnv</span>(<span class="hljs-params">env, name, value</span>) </span>{
  <span class="hljs-keyword">let</span> envAddition = {}
  envAddition[name] = value

  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign({}, env, envAddition)
}</code></pre>
          <p>Or, using some of the latest and greatest JavaScript features:</p>
          <pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extendEnv</span>(<span class="hljs-params">env, name, value</span>) </span>{
  <span class="hljs-keyword">return</span> {
    ...env,
    [name]: value,
  }
}</code></pre>
          <p>
            Putting it all together, the combination of <code>lookup</code>,
            <code>extendEnv</code>, and <code>evaluate</code> completes the
            language.
          </p>
          <pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lookup</span>(<span class="hljs-params">env, name</span>) </span>{
  <span class="hljs-keyword">return</span> env[name]
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extendEnv</span>(<span class="hljs-params">env, name, value</span>) </span>{
  <span class="hljs-keyword">return</span> {
    ...env,
    [name]: value,
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">evaluate</span>(<span class="hljs-params">node, env</span>) </span>{
  <span class="hljs-keyword">switch</span> (node.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">"String"</span>:
      <span class="hljs-keyword">return</span> node.content
    <span class="hljs-keyword">case</span> <span class="hljs-string">"Excite"</span>:
      <span class="hljs-keyword">return</span> evaluate(node.expression, env) + <span class="hljs-string">"!"</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">"Append"</span>:
    <span class="hljs-comment">// Left as an exercise to the reader</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">"Variable"</span>:
      <span class="hljs-keyword">return</span> lookup(env, node.name)
    <span class="hljs-keyword">case</span> <span class="hljs-string">"Let"</span>:
      <span class="hljs-keyword">let</span> inner = node.expression
      <span class="hljs-keyword">let</span> value = evaluate(node.value, env)
      <span class="hljs-keyword">let</span> newEnv = extendEnv(env, node.name, value)
      <span class="hljs-keyword">return</span> evaluate(node.expression, newEnv)
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">throw</span> <span class="hljs-string">`evaluate -- unknown node type <span class="hljs-subst">${node.type}</span>`</span>
  }
}</code></pre>
          <h2 id="closing-notes-and-things-to-ponder">
            Closing notes and things to ponder
          </h2>
          <p>
            If you made it to the end of this post, congratulations and thank
            you :)
          </p>
          <p>
            We developed a language and an evaluator that processes
            <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree"
              >Abstract Syntax Trees</a
            >
            (or ASTs for short, but I just called &#39;em nodes for simplicity).
            Our language has
            <a
              href="https://en.wikipedia.org/wiki/Constant_(computer_programming"
              >constants</a
            >, some small expressions to operate on strings, and
            <a href="https://en.wikipedia.org/wiki/Variable_(computer_science"
              >variables</a
            >.
          </p>
          <p>
            But this is only the beginning! You are ending this article with an
            <code>evaluate</code> function that can grow to support all sorts of
            common language features (numbers, comments, functions), the only
            limit is your imagination.
          </p>
          <p>
            I&#39;d like to leave you with a few concrete exercises, should you
            wish to revisit your new language on a rainy day:
          </p>
          <ul>
            <li>
              How might we add Numbers to our language? How about operations to
              Add and Multiply them? What about <em>rational</em> numbers
              (fractions with a numerator and a denominator)?
            </li>
            <li>
              As we saw earlier, we can kickstart our <code>env</code> by
              populating it with global values. Could we add functions to this
              environment? How might we call them from our language?
            </li>
            <li>
              Can we take our abstract syntax tree and use it to generate
              JavaScript code? How about Ruby code?
            </li>
            <li>
              Writing our programs in as JavaScript objects doesn&#39;t seem to
              scale well. How might we go about creating a
              <strong>syntax</strong> for our language and converting that to an
              AST?
            </li>
          </ul>
          <p>
            I&#39;ll also go ahead and plug some of my favorite resources on
            Programming Languages.
          </p>
          <ul>
            <li>
              Dan Grossman&#39;s
              <a href="https://www.coursera.org/learn/programming-languages"
                >Programming Languages on Coursera</a
              >
              is an entirely free, entirely amazing three-part course for
              learning the ins and outs of different types of programming
              languages. I can&#39;t recommend it enough.
            </li>
            <li>
              This article is inspired in no short part by
              <a href="https://github.com/jamiebuilds/the-super-tiny-compiler"
                >@jamiebuilds&#39;s super tiny compiler</a
              >. I encourage you to check out the code to see some of the
              concepts introduced in this article in more detail.
            </li>
            <li>
              <a href="https://craftinginterpreters.com/"
                >Crafting Interpreters</a
              >
              is an effort to build &quot;a handbook for making programming
              languages.&quot; An ambitious goal, but it&#39;s completely free
              and chock full of different interpreter concepts.
            </li>
          </ul>
          <p>
            That&#39;s all for now. If you liked this article feel free to share
            it and follow me on Twitter while you&#39;re at it:
            <a href="https://twitter.com/jdan">@jdan</a>.
          </p>
          <p>
            You should also come work with me at
            <a href="https://stripe.com/jobs">Stripe</a>. We&#39;re hiring all
            over the place.
          </p>
          <p>
            Thanks again for reading,<br />
            Jordan
          </p>
        </section>

        <footer class="more details">
          --
          <br /><br />
          <a
            target="_blank"
            href="https://twitter.com/intent/tweet?text=%E2%80%9CA%20Frontend%20Programmer&#39;s%20Guide%20to%20Languages%E2%80%9D%20by%20%40jdan%20%E2%80%93%20http%3A%2F%2Fthatjdanisso.cool%2Fprogramming-languages"
            class="tweet"
            >tweet this</a
          >
          <a href="/">&laquo; back to home</a>
        </footer>
      </article>
    </div>

    <script async src="/js/flasher.js"></script>
    <script async src="/js/demos/clicking.js"></script>
    <script async src="/js/demos/hover.js"></script>
    <script>
      ;(function(i, s, o, g, r, a, m) {
        i["GoogleAnalyticsObject"] = r
        ;(i[r] =
          i[r] ||
          function() {
            ;(i[r].q = i[r].q || []).push(arguments)
          }),
          (i[r].l = 1 * new Date())
        ;(a = s.createElement(o)), (m = s.getElementsByTagName(o)[0])
        a.async = 1
        a.src = g
        m.parentNode.insertBefore(a, m)
      })(
        window,
        document,
        "script",
        "//www.google-analytics.com/analytics.js",
        "ga"
      )
      ga("create", "UA-60897046-1", "auto")
      ga("send", "pageview")
    </script>
  </body>
</html>
