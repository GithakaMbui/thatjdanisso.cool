<!DOCTYPE html>
<html lang="en">
  <head>
    <title>
      How to build disruptive OCaml microservices with BuckleScript | jordan
      scales
    </title>

    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/tomorrow.min.css" />
    <link rel="stylesheet" href="/css/demos/clicking.css" />
    <link rel="stylesheet" href="/css/demos/hover.css" />
    <link rel="stylesheet" href="/css/demos/shared.css" />
    <link rel="stylesheet" href="/css/katex.min.css" />

    <link
      href="https://fonts.googleapis.com/css?family=Inconsolata:400,700"
      rel="stylesheet"
      type="text/css"
    />
    <meta charset="utf-8" />
    <meta name="viewport" content="width=480" />
    <link
      rel="Shortcut Icon"
      type="image/x-icon"
      href="https://s.gravatar.com/avatar/3517596df161030c3779c532f7844383?s=32.gif"
    />

    <meta
      property="og:title"
      content="How to build disruptive OCaml microservices with BuckleScript | jordan scales"
    />
    <meta
      name="Description"
      content="For a few hours this past week, I decided to cram a bunch of different Very Fun™ things together to build a trivial web app."
    />
    <meta
      property="og:description"
      content="For a few hours this past week, I decided to cram a bunch of different Very Fun™ things together to build a trivial web app."
    />
    <meta
      property="og:image"
      content="https://s.gravatar.com/avatar/3517596df161030c3779c532f7844383?s=32.gif"
    />
  </head>

  <body>
    <div class="main">
      <header>
        <span class="flash" aria-hidden="true">////////</span>
        <strong>jordan scales</strong>
        <span class="sep" aria-hidden="true">.</span>
        <a href="/">home</a>
        <span class="sep" aria-hidden="true">.</span>
        <a href="/projects">projects</a>
        <span class="sep" aria-hidden="true">.</span>
        <a href="https://twitter.com/jdan">twitter</a>
        <span class="sep" aria-hidden="true">.</span>
        <a href="https://github.com/jdan">github</a>
      </header>

      <article class="article">
        <header class="title">
          <div class="date">
            August 15, 2017
          </div>

          <h1>How to build disruptive OCaml microservices with BuckleScript</h1>
        </header>

        <section class="content">
          <p>
            Recently, I started tinkering with
            <a href="https://ocaml.org/">OCaml</a>. It’s Very Fun™, which makes
            it a great fit for a quick side project. So, for a few hours this
            past week, I decided to cram a bunch of different Very Fun™ things
            together to build a trivial web app. It went well — so here’s a
            tutorial on how I did it.
          </p>
          <hr />
          <h3 id="the-plan">The Plan</h3>
          <p>
            We’ll be writing a few lines of
            <a href="https://ocaml.org/">OCaml</a>, compiling it to JavaScript
            using
            <a href="https://github.com/bucklescript/bucklescript"
              >BuckleScript</a
            >, producing a .js file which runs a microservice using
            <a href="https://github.com/zeit/micro">Micro</a>.
          </p>
          <p>
            “Fatigue!” you may claim. Yeah, that’s kinda the point. We’ll get
            our hands dirty with a variety of cool things, each of which can be
            further explored or ignored as you see fit — that was my plan,
            anyway.
          </p>
          <h3 id="the-tools">The Tools</h3>
          <p>We’ll need a couple things from npm:</p>
          <pre><code>yarn <span class="hljs-keyword">add</span> micro   # <span class="hljs-keyword">or</span> replace <span class="hljs-string">'yarn'</span> <span class="hljs-keyword">with</span> <span class="hljs-string">'npm install'</span>
yarn <span class="hljs-keyword">add</span> --dev bs-<span class="hljs-keyword">platform</span></code></pre>
          <p>Allow me to briefly explain what these two things are.</p>
          <hr />
          <p>
            <a href="https://github.com/zeit/micro">Micro</a> is a super-tiny
            library for turning blocks of code like this…
          </p>
          <pre><code><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">(req, res)</span> =&gt;</span> {
  res.end(<span class="hljs-string">'Welcome to Micro'</span>)
}</code></pre>
          <p>
            …into web-servers. Just a few lines, no need for any boilerplate or
            configuration, making our lives much easier as we attempt to compile
            another language into it.
          </p>
          <p>
            <a href="https://github.com/bucklescript/bucklescript"
              >BuckleScript</a
            >
            is a toolchain developed at Bloomberg for compiling OCaml code into
            readable, performant JavaScript. It is incredibly powerful, and
            we’ll only be using a very, *very *small subset of its features, but
            it works quite well and is easy to get up and running.
          </p>
          <hr />
          <p>Now a bit of config.</p>
          <p>
            First we’ll need to tell BuckleScript where our files are (let’s
            make a new <code>src/</code> directory and just put things in
            there). To do this we create a <code>bsconfig.json</code> with the
            following two fields.
          </p>
          <pre><code>{
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"bucklescript-micro-example"</span>,
  <span class="hljs-attr">"sources"</span>: [
    <span class="hljs-string">"src/"</span>
  ]
}</code></pre>
          <p>
            Sa-weet — now let’s add some scripts to <code>package.json</code> to
            make our lives easier.
          </p>
          <pre><code>{
  <span class="hljs-attr">"dependencies"</span>: {
    <span class="hljs-attr">"micro"</span>: <span class="hljs-string">"^8.0.1"</span>
  },
  <span class="hljs-attr">"devDependencies"</span>: {
    <span class="hljs-attr">"bs-platform"</span>: <span class="hljs-string">"^1.8.2"</span>
  },
  <span class="hljs-attr">"scripts"</span>: {
    <span class="hljs-attr">"build"</span>: <span class="hljs-string">"bsb"</span>,
    <span class="hljs-attr">"watch"</span>: <span class="hljs-string">"bsb -w"</span>,
    <span class="hljs-attr">"start"</span>: <span class="hljs-string">"node lib/js/src/index.js"</span>
  }
}</code></pre>
          <p>
            Our <code>build</code> command will use the
            <code>bsb</code> executable (provided to us from
            <code>bs-platform</code>) to build our code. <code>watch</code> does
            the same thing, but will also watch for any file changes as we
            develop and re-build them automagically.
          </p>
          <p>
            Finally, <code>start</code> will run our web server. The path
            afterwards is where BuckleScript will put our compiled JavaScript.
          </p>
          <h3 id="the-code">The Code</h3>
          <p>
            So far so good, right? Now, we can start writing code. Let’s kick
            things off with a simple function, just to get a feel for how
            BuckleScript works its magic. Start by creating a file
            <code>src/add.ml</code> and add the following:
          </p>
          <pre><code>let add <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> = <span class="hljs-selector-tag">a</span> + b</code></pre>
          <p>
            If we run <code>npm run build</code> (or we can run
            <code>npm run watch</code> and leave it in a separate tab), we
            should see a brand new <code>lib/</code> folder in our profile.
            Diving in, we find lots of definitions, and the compiled output:
            <code>lib/src/add.js</code>:
          </p>
          <pre><code><span class="hljs-comment">// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE</span>
<span class="hljs-meta">'use strict'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">return</span> a + b | <span class="hljs-number">0</span>;
}

exports.add = add;
<span class="hljs-comment">/* No side effect */</span></code></pre>
          <p>
            Magic! Not only did we compile the code, but we’re exporting our
            <code>add</code> function (with the right name and all). We can now
            use our <code>add</code> function, originally written in OCaml, in
            node:
          </p>
          <pre><code>$ <span class="hljs-keyword">node</span>
<span class="hljs-title">&gt; require</span>(<span class="hljs-string">"./lib/js/src/add.js"</span>).add(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>)
<span class="hljs-number">11</span></code></pre>
          <p>
            Now the fun part — let’s try to write some code that uses
            <a href="https://github.com/zeit/micro">micro</a>.
          </p>
          <h3 id="the-bindings">The Bindings</h3>
          <p>
            We can write functions like <code>add</code> ourselves, but in order
            to interface our code with existing JS functions, we’ll need to dive
            into the world of
            <a href="https://en.wikipedia.org/wiki/Foreign_function_interface"
              >foreign function interface</a
            >_s _(also known as FFIs).
          </p>
          <p>Simply put, FFIs let BuckleScript know:</p>
          <ul>
            <li>
              <strong>The type definitions of our foreign objects</strong>. This
              allows us to treat these objects as first class citizens, passing
              them to and from other functions in our codebase. (For example,
              <code>micro</code> will provide us with “request” and “response”
              objects. We can type these so later on we can write functions such
              as <code>renderIndexPage : res -&gt; string -&gt; unit</code>).
            </li>
            <li>
              *<em
                >What type of syntax our OCaml code should compile down to.
                *</em
              >In other words, should
              <code>fillStyle ctx &quot;blue&quot;</code> compile down to
              <code>ctx.fillStyle(&quot;blue&quot;)</code> or
              <code>ctx.fillStyle = &quot;blue&quot;</code>?
            </li>
          </ul>
          <p>
            These bullet points will make more sense as we go along. For now,
            let me introduce what one of these bindings looks like.
          </p>
          <pre><code>type req<span class="hljs-built_in">
type </span>res<span class="hljs-built_in">
type server
</span>external micro : (req -&gt; res -&gt; string) -&gt;<span class="hljs-built_in"> server </span>= <span class="hljs-string">"micro"</span> [@@bs.module]
external listen :<span class="hljs-built_in"> server </span>-&gt; int -&gt; unit = <span class="hljs-string">"listen"</span> [@@bs.send]</code></pre>
          <p>Let’s break this down.</p>
          <ul>
            <li>
              First we define a few types. Now we can create functions that
              consume/return a “thing” of type <code>req</code>,
              <code>res</code>, and <code>server</code>.
            </li>
            <li>
              <code>external</code> is a keyword used for defining FFIs in
              OCaml. You’ll see this a lot when working with BuckleScript
            </li>
            <li>
              <code>micro</code> and <code>listen</code> will correspond to
              functions we can now use in our OCaml code. Thanks to the type
              definitions next to them (after the colon), they are typesafe and
              will let your program compile (as well as make tooling such as
              <a href="https://github.com/ocaml/merlin">merlin</a> infinitely
              more useful).
            </li>
            <li>
              The strings <code>&quot;micro&quot;</code> and
              <code>&quot;listen&quot;</code>, somewhat confusingly, correspond
              to the JavaScript identifiers that BuckleScript will output. We
              can technically leave these out (and instead specify
              <code>&quot;&quot;</code>) since they are equal to the function
              names we are binding to.
            </li>
            <li>
              Finally, the items in the square brackets (namely
              <code>bs.module</code> and <code>bs.send</code>) let BuckleScript
              know what sort of JavaScript expression we want our new
              <code>micro</code> and <code>listen</code> functions to compile
              to.
            </li>
          </ul>
          <hr />
          <p>I’d like to expand that last bullet point.</p>
          <h4 id="bssend"><code>[@@bs.send]</code></h4>
          <p>
            This treats the first argument as a JS object and sends the
            remaining arguments as parameters.
          </p>
          <pre><code>external listen :<span class="hljs-built_in"> server </span>-&gt; int -&gt; unit = <span class="hljs-string">"listen"</span> [@@bs.send]
(* <span class="hljs-built_in">..</span>.other stuff<span class="hljs-built_in">..</span>. *)
listen thing_of_type_server 1337</code></pre>
          <p>Will result in (roughly) the following code:</p>
          <pre><code>thing_of_type_server.<span class="hljs-section">listen</span>(<span class="hljs-number">1337</span>)</code></pre>
          <h4 id="bsmodule">[@@bs.module]</h4>
          <p>
            This attribute lets BuckleScript know that you are interfacing with
            a JS module, adding a <code>require</code> when necessary.
          </p>
          <pre><code><span class="hljs-keyword">external</span> add : <span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">int</span> = <span class="hljs-string">"add"</span> [@@bs.<span class="hljs-keyword">module</span>]
<span class="hljs-keyword">external</span> sub : <span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">int</span> = <span class="hljs-string">"sub"</span> [@@bs.<span class="hljs-keyword">module</span> <span class="hljs-string">"coolpackage"</span>]
<span class="hljs-keyword">let</span> f = add <span class="hljs-number">1</span> <span class="hljs-number">2</span>;;
<span class="hljs-keyword">let</span> g = sub <span class="hljs-number">7</span> <span class="hljs-number">6</span>;;</code></pre>
          <p>Results in:</p>
          <pre><code><span class="hljs-attribute">var Add</span>         = require(<span class="hljs-string">"add"</span>);
<span class="hljs-attribute">var Coolpackage</span> = require(<span class="hljs-string">"coolpackage"</span>);

<span class="hljs-attribute">var f</span> = Add(1, 2);
<span class="hljs-attribute">var g</span> = Coolpackage.sub(7, 6);</code></pre>
          <p>
            <strong>As an exercise to the reader: what do the attributes</strong
            ><code>[@@bs.get]</code><strong>, **<code>[@@bs.set]</code></strong
            >, and <strong><code>[@@bs.val]</code></strong> do?**
          </p>
          <p>
            For more on FFI: refer to the
            <a
              href="https://bucklescript.github.io/bucklescript/Manual.html#_ffi"
              >official BuckleScript docs</a
            >.
          </p>
          <hr />
          <p>
            We now have access to two functions: <code>micro</code> and
            <code>listen</code> which are used in the following ways:
          </p>
          <p>
            <code>micro</code> accepts a function (which accepts two arguments
            of type <code>req</code> and <code>res</code> respectively and
            returns a <code>string</code>) and returns a <code>server</code>.
          </p>
          <pre><code>let server = micro (<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">req</span></span> -&gt; <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">res</span></span> -&gt; <span class="hljs-string">"Hello, world!"</span>);;</code></pre>
          <p>
            <code>listen</code> accepts a <code>server</code> and an
            <code>int</code> and returns a noop (type <code>unit</code>).
          </p>
          <pre><code>listen<span class="hljs-built_in"> server </span>1337;;</code></pre>
          <p>All together now!</p>
          <pre><code>type req<span class="hljs-built_in">
type </span>res<span class="hljs-built_in">
type server
</span>external micro : (req -&gt; res -&gt; string) -&gt;<span class="hljs-built_in"> server </span>= <span class="hljs-string">"micro"</span> [@@bs.module]
external listen :<span class="hljs-built_in"> server </span>-&gt; int -&gt; unit = <span class="hljs-string">"listen"</span> [@@bs.send]

let<span class="hljs-built_in"> server </span>= micro (fun req -&gt; fun res -&gt; <span class="hljs-string">"Hello, world!"</span>);;
listen<span class="hljs-built_in"> server </span>1337;;</code></pre>
          <p>
            If we place this code in <code>src/index.ml</code>, running
            <code>npm run build</code> will produce
            <code>lib/js/src/index.js</code> with the following contents:
          </p>
          <pre><code><span class="hljs-comment">// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE</span>
<span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">var</span> Micro = <span class="hljs-built_in">require</span>(<span class="hljs-string">"micro"</span>);

<span class="hljs-keyword">var</span> server = Micro((<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_, _$<span class="hljs-number">1</span></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello, world!"</span>;
      }));

server.listen(<span class="hljs-number">1337</span>);

exports.server = server;
<span class="hljs-comment">/* server Not a pure module */</span></code></pre>
          <p>
            Now let’s run <code>npm start</code> and visit
            <code>localhost:1337</code> .
          </p>
          <p>
            <img
              src="https://cdn-images-1.medium.com/max/1600/1*MNeQbgDiAklOzLuQMwlrIA.png"
              alt='A screenshot of a web browser showing a document with the text "Hello, world!"'
            />
          </p>
          <p>
            Better yet, we can install
            <a href="https://github.com/zeit/now">now</a> (<code
              >npm install -g now</code
            >) and deploy our site instantly (simply by typing
            <code>now</code> in our terminal).
          </p>
          <p>
            <img
              src="https://cdn-images-1.medium.com/max/1600/1*jIDDvhlUevt-3yRUKr6HlA.png"
              alt='A screenshot of a web browser showing a document with the text "Hello, world!"'
            />
          </p>
          <p>
            And Voila! A “web-server” written in OCaml, compiled down to
            JavaScript. It’s not much, but it’s a straight spike through a
            variety of technologies. Hopefully you find one or two of ’em
            interesting, and I encourage you to continue playing and exploring.
          </p>
          <h3 id="going-forward">Going Forward</h3>
          <p>Here are some more questions to ponder on.</p>
          <ul>
            <li>
              Using micro, the first argument represents an instance of
              <code>http.IncomingMessage</code>. This instance has a
              <code>url</code> property —
              <strong
                >how would we go about extracting the URL and displaying a
                different message?</strong
              >
            </li>
            <li>
              If we surround <code>Hello, world!</code> with
              <code>&lt;strong&gt;&lt;/strong&gt;</code>, we see that our
              browser renders an HTML document.
              <strong
                >Experiment with creating various “template” functions</strong
              >
              to build a Real Website™. (i.e.
              <code>fun req -&gt; fun res -&gt; layout req</code>)
            </li>
            <li>
              Instead of returning a string,
              <strong>use various methods on the **<code>res</code></strong>
              parameter**, which is an instance of
              <code>http.ServerResponse</code>.
            </li>
          </ul>
          <p>
            You may also be interested in
            <a href="http://facebook.github.io/reason/">Reason</a>: a new syntax
            for OCaml developed at Facebook. It’s gaining a lot of traction in
            the JavaScript community, and even has
            <a href="https://reasonml.github.io/reason-react/">React bindings</a
            >! I’m personally a huge fan of my friend Jared’s recent (excellent)
            <a
              href="https://jaredforsyth.com/2017/07/05/a-reason-react-tutorial/"
              >blog post about ReasonReact</a
            >.
          </p>
          <p>
            In part 2, We’ll explore <code>@@bs.send.pipe</code> and how to
            better interface with chainable JavaScript APIs:
          </p>
          <p>
            <a href="/js-ocaml-chaining"
              >Typesafe JavaScript Chaining with OCaml and BuckleScript</a
            >
          </p>
          <p>
            I hope this serves as a gentle introduction to one of my favorite
            things happening in JavaScript right now. Go forth and explore, and
            be sure to share what you create.
          </p>
        </section>

        <footer class="more details">
          --
          <br /><br />
          <a
            target="_blank"
            href="https://twitter.com/intent/tweet?text=%E2%80%9CHow%20to%20build%20disruptive%20OCaml%20microservices%20with%20BuckleScript%E2%80%9D%20by%20%40jdan%20%E2%80%93%20http%3A%2F%2Fthatjdanisso.cool%2Fjs-ocaml-microservices"
            class="tweet"
            >tweet this</a
          >
          <a href="/">&laquo; back to home</a>
        </footer>
      </article>
    </div>

    <script async src="/js/flasher.js"></script>
    <script async src="/js/demos/clicking.js"></script>
    <script async src="/js/demos/hover.js"></script>
    <script>
      ;(function(i, s, o, g, r, a, m) {
        i["GoogleAnalyticsObject"] = r
        ;(i[r] =
          i[r] ||
          function() {
            ;(i[r].q = i[r].q || []).push(arguments)
          }),
          (i[r].l = 1 * new Date())
        ;(a = s.createElement(o)), (m = s.getElementsByTagName(o)[0])
        a.async = 1
        a.src = g
        m.parentNode.insertBefore(a, m)
      })(
        window,
        document,
        "script",
        "//www.google-analytics.com/analytics.js",
        "ga"
      )
      ga("create", "UA-60897046-1", "auto")
      ga("send", "pageview")
    </script>
  </body>
</html>
